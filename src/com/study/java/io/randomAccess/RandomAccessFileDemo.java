package com.study.java.io.randomAccess;import java.io.IOException;import java.io.RandomAccessFile;/** *  * @author YLS *  * 通过RandomAccessFile这个流结合线程来完成大文件的拷贝，但是这个并不是线程越多越好，而是应该权衡之后再做决定 * */public class RandomAccessFileDemo {	//.\\src\\com\\study\\java\\io\\inOutPutStream\\1.avi	public static void main(String[] args) {		long start = System.currentTimeMillis();		String source_dir = "H:\\鍙舵灄鐢焅\\涓嬭浇.rar";		String aim_dir = ".\\src\\com\\study\\java\\io\\randomAccess\\涓嬭浇.rar";		FileSource source = new FileSource(source_dir);		int num = source.getThreadNum();		RandAccessInOutput inOutput = null;		for (int i = 0; i < num; i++) {			inOutput = new RandAccessInOutput(source, source_dir, aim_dir);			new Thread(inOutput).start();		}		long end = System.currentTimeMillis();		System.out.println(end - start);	}}class RandAccessInOutput implements Runnable{		private FileSource source = null;	private RandomFile randomFile = null;	private String source_dir = "/";	private String aim_dir = "/";		public RandAccessInOutput(FileSource source, String source_dir, String aim_dir) {		this.source = source;		this.source_dir = source_dir;		this.aim_dir = aim_dir;	}	@Override	public void run() {		long start = System.currentTimeMillis();		randomFile = new RandomFile(source);		copyFile();		long end = System.currentTimeMillis();		System.out.println(end - start);	}		public void copyFile(){		RandomAccessFile read = null;		RandomAccessFile write = null;		try {			long index = (RandomFile.getThreadID() - 1) * source.EACH_PART_SIZE;			read = new RandomAccessFile(source_dir, "rw");			write = new RandomAccessFile(aim_dir, "rw");			read.seek(index);			write.seek(index);			byte[] b = new byte[1024 * 10];			int ch = 0;			long len = 0;			while(true) {				if (len == randomFile.getPos()) 					break;				ch = read.read(b);				if (ch == -1)					break;								write.write(b, 0, ch);				len += ch;			}		} catch (IOException | IndexOutOfBoundsException e) {			e.printStackTrace();		} finally {			if (read != null) {				try {					read.close();				} catch (IOException e) {					e.printStackTrace();				} finally {					if (write != null) {						try {							write.close();						} catch (IOException e) {							e.printStackTrace();						}					}				}			}		}	}}