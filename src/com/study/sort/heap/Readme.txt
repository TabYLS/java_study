最好，最坏，平均的时间复杂度都是O(n*log2n)
空间复杂度是O(1)

说明：参考这个通过图解理解流程http://www.cnblogs.com/chengxiao/p/6129630.html
堆在实际存储的时候用的也是数组，但是操作的时候，操作逻辑却是按照堆的特性来操作的所以重点在于理解堆的特点
（这里假设采用的是大顶堆）
1.首先进来的时候需要将整个堆的数据初始化一下，初始化成一个符合堆定义的结构，所以需要对每一个节点都进行调整
	第一次调整的时候取最后一个非叶子节点的位置开始（初始位置：arr.length/2）：for(int i = arr.length/2 - 1; i >= 0; i --)
2.然后将符合堆结构的数据进行交换，交换第一个和最后一个节点，交换完成之后就会破坏堆的结构（因为根节点不是最大的，所以不满足大顶堆）所以要对它进行再次的调整
	因为只交换了一个节点，所以只需要对一个节点进行调整即可（也就是第一个和最后一个：adjustHeap(arr,0,j);），在每次交换完成并且调整结构之后，堆的大小减一
	因为通过不停的交换和调整结构才可以实现对数据的排序，但是由于算法的特性，每次交换都是把根节点左边的子节点调整到根节点，
	然后再和右边的子节点进行交换，但是依然需要遍历每个节点（：for(int j=arr.length-1;j>0;j--)），因为交换之后是把右边的节点转移到了左边

	
调整的过程：
	1.首先要取出指定的节点，也就是根节点，因为后面的调整方式是通过直接覆盖的方式
	2.从该节点的左孩子开始：int k=i*2+1，遍历每个非叶子节点:k=k*2+1，如果到达了叶子节点：k<length(最后一次的时候叶子节点就是最后一行的下一个作节点，肯定会比堆的长度大，所以就不会满足条件)就跳出循环
	3.将较大的数往根节点移动，因为大顶堆就是通过每次调整根节点最大从而实现排序的
		 if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;//将子节点的位置给父节点，这样不停的覆盖父节点就会导致第一个父节点没有所以后面需要复原，此时已经变成子节点
            }else{
                break;
            }
     4.结束之后就发现有两个重复的元素也就是第一次回调整的时候被覆盖的那个父节点，所以要对它进行复原